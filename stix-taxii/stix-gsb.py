import sqlite3
import json
from stix2.v21 import (Indicator, KillChainPhase, Malware, Relationship, Bundle)
import requests
import datetime

conn = sqlite3.connect('../database/threats.db')## connects to db
conn.text_factory = str
c = conn.cursor()##opens cursor for db transactions

c.execute("DROP TABLE IF EXISTS stix_table")
c.execute("CREATE TABLE IF NOT EXISTS stix_table (stix string);")
c.execute("SELECT * FROM threats_table;")

api_key = "AIzaSyBV4vY0K3XsfMMKGaGPmx8ccgTnyjI1trM"
url = "https://safebrowsing.googleapis.com/v4/threatMatches:find"
params = {'key': "AIzaSyBV4vY0K3XsfMMKGaGPmx8ccgTnyjI1trM"}

rows = c.fetchall()
for row in rows:

    # GOOGLE SAFE BROWSING

    url_to_check = row[1]
    if url_to_check == "-":
        url_to_check = row[0]
    
    payload = {'client': {'clientId': "panagiotis", 'clientVersion': "0.1"},
            'threatInfo': {'threatTypes': ["SOCIAL_ENGINEERING", "MALWARE", "THREAT_TYPE_UNSPECIFIED", "UNWANTED_SOFTWARE", "POTENTIALLY_HARMFUL_APPLICATION"],
                        'platformTypes': ["ANY_PLATFORM"],
                        'threatEntryTypes': ["URL"],
                        'threatEntries': [{'url': url_to_check}]}}
    r = requests.post(url, params=params, json=payload)
    response = r.json()
    if response:
        isFound = 'True'
    else:
        isFound = 'False'

    # STIX2 FORMAT
    indicator = Indicator(
        created = datetime.datetime.now(),
        name="Malicious content",
        indicator_types=["malicious-activity"],
        pattern="[url:value = '{}']".format(url_to_check),
        pattern_type="stix",
        valid_from=datetime.datetime.now())

    malware = Malware(
        created=datetime.datetime.now(),
        name=row[2],
        custom_properties={
            "country": row[5],
            "os": row[6],
            "city": row[7],
            "google_safe_browsing": isFound
            },
        is_family="false")

    relationship = Relationship(indicator, 'indicates', malware)

    bundle = Bundle(objects=[indicator, malware, relationship])

    to_db = json.dumps(str(dict(bundle)))
    print(to_db)
    c.execute("INSERT INTO stix_table (stix) VALUES(?);", (to_db, ))
    conn.commit()